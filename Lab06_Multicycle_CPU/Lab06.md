相对上一个实验的改进：

对于存储器位宽为32，而PC=PC+4是以8位为位宽的写法，在上一次实验中为了图简便，将此式写为PC=PC+1。本次实验进一步统一地址的表示。内部地址的计算几乎完全按照原有的8位位宽地址来。只是在取数存数时，将地址除以4。

多周期相对单周期的一个重大的不同是：运算单元可以先后复用：先用来计算地址（R型指令），后用来计算自增的PC（个人觉得大材小用，这使得我上次实验写的PC之后的表达式全要重写！）。

对用各寄存器来暂存输出（如r1\_dout, r2\_dout都用寄存器来阻断）表示不太理解。寄存器更多地是为流水线而准备的。

理解了！为什么需要instruction寄存器。因为一条指令的执行过程中可能会再次访存，此时m_dout的改变会影响到instruction。

寄存器堆是异步的！寄存器值的输出是组合逻辑！

寄存器的一个目的是：强制将信号阻塞到下一周期，强制实现同步。

对PC跳转、分支、还是正常自增的逻辑现在放到了control里面。

使用同步存储器，对状态机的修改：

- 增加状态：S5plus、S8plus、S11plus

  都是为了为S0的取指做好准备。要使S0执行时，PC已经为正确的PC，这样S0执行后即可得到指令字。

  没有按照PPT接线图那样另外增添mem_data寄存器。增添寄存器的代价是需要等待一个时钟使值写入寄存器。

S0的控制信号：PCWrite，实际上在S1才起作用。故PC要等到S1才能被修改。

各个之前状态发出的信号，在下一状态要及时去除。以免发生意想不到的错误。

0x00002000远超IP核的地址范围。将数据段起始地址改为：0x00000100

调试过程中的bug记录：

- `.addra(Mem_addr>>2)`写成了`.addra(Mem_addr<<2)`